// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v3.21.12
// source: misc/common.proto
/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
export const protobufPackage = "misc";
export const CompressionType = {
    UNKNOWN: 0, 0: "UNKNOWN",
    GZIP: 1, 1: "GZIP",
    BROTLI: 2, 2: "BROTLI",
    UNRECOGNIZED: -1, "-1": "UNRECOGNIZED"
};
export const AudioQuality = {
    UNKNOWN: 0, 0: "UNKNOWN",
    ULTRALOW: 5, 5: "ULTRALOW",
    LOW: 10, 10: "LOW",
    MEDIUM: 20, 20: "MEDIUM",
    HIGH: 30, 30: "HIGH",
    UNRECOGNIZED: -1, "-1": "UNRECOGNIZED"
};
export const VideoQualitySetting = {
    UNKNOWN: 0, 0: "UNKNOWN",
    HIGHER_QUALITY: 1, 1: "HIGHER_QUALITY",
    DATA_SAVER: 2, 2: "DATA_SAVER",
    ADVANCED_MENU: 3, 3: "ADVANCED_MENU",
    UNRECOGNIZED: -1, "-1": "UNRECOGNIZED"
};
export const PlaybackAudioRouteOutputType = {
    UNKNOWN: 0, 0: "UNKNOWN",
    LINE_OUT: 1, 1: "LINE_OUT",
    HEADPHONES: 2, 2: "HEADPHONES",
    BLUETOOTH_A2DP: 3, 3: "BLUETOOTH_A2DP",
    BUILT_IN_RECEIVER: 4, 4: "BUILT_IN_RECEIVER",
    BUILT_IN_SPEAKER: 5, 5: "BUILT_IN_SPEAKER",
    HDMI: 6, 6: "HDMI",
    AIR_PLAY: 7, 7: "AIR_PLAY",
    BLUETOOTH_LE: 8, 8: "BLUETOOTH_LE",
    BLUETOOTH_HFP: 9, 9: "BLUETOOTH_HFP",
    USB_AUDIO: 10, 10: "USB_AUDIO",
    CAR_PLAY: 11, 11: "CAR_PLAY",
    ANDROID_AUDIO: 12, 12: "ANDROID_AUDIO",
    UNRECOGNIZED: -1, "-1": "UNRECOGNIZED"
};
export const NetworkMeteredState = {
    UNKNOWN: 0, 0: "UNKNOWN",
    UNMETERED: 1, 1: "UNMETERED",
    METERED: 2, 2: "METERED",
    UNRECOGNIZED: -1, "-1": "UNRECOGNIZED"
};
export const SeekSource = {
    UNKNOWN: 0, 0: "UNKNOWN",
    TIMESTAMP_IN_COMMENTS: 1, 1: "TIMESTAMP_IN_COMMENTS",
    TIMESTAMP_IN_DESCRIPTION: 2, 2: "TIMESTAMP_IN_DESCRIPTION",
    MACRO_MARKER_LIST_ITEM: 3, 3: "MACRO_MARKER_LIST_ITEM",
    DOUBLE_TAP_TO_SEEK: 4, 4: "DOUBLE_TAP_TO_SEEK",
    DOUBLE_TAP_TO_SKIP_CHAPTER: 5, 5: "DOUBLE_TAP_TO_SKIP_CHAPTER",
    PICK_UP_PLAY_HEAD: 6, 6: "PICK_UP_PLAY_HEAD",
    SLIDE_ON_SCRUBBER_BAR: 7, 7: "SLIDE_ON_SCRUBBER_BAR",
    SLIDE_ON_PLAYER: 8, 8: "SLIDE_ON_PLAYER",
    SABR_PARTIAL_CHUNK: 9, 9: "SABR_PARTIAL_CHUNK",
    SABR_SEEK_TO_HEAD: 10, 10: "SABR_SEEK_TO_HEAD",
    SABR_LIVE_DVR_USER_SEEK: 11, 11: "SABR_LIVE_DVR_USER_SEEK",
    SABR_SEEK_TO_DVR_LOWER_BOUND: 12, 12: "SABR_SEEK_TO_DVR_LOWER_BOUND",
    SABR_SEEK_TO_DVR_UPPER_BOUND: 13, 13: "SABR_SEEK_TO_DVR_UPPER_BOUND",
    SSDAI_INTERNAL: 14, 14: "SSDAI_INTERNAL",
    START_PLAYBACK: 15, 15: "START_PLAYBACK",
    SABR_ACCURATE_SEEK: 17, 17: "SABR_ACCURATE_SEEK",
    START_PLAYBACK_SEEK_TO_END: 18, 18: "START_PLAYBACK_SEEK_TO_END",
    IOS_PLAYER_REMOVED_SEGMENTS: 19, 19: "IOS_PLAYER_REMOVED_SEGMENTS",
    IOS_PLAYER_SEGMENT_LIST: 20, 20: "IOS_PLAYER_SEGMENT_LIST",
    IOS_PLAYER_ITEM_SEEK: 21, 21: "IOS_PLAYER_ITEM_SEEK",
    IOS_PLAYER_ITEM_SEEK_TO_END: 22, 22: "IOS_PLAYER_ITEM_SEEK_TO_END",
    IOS_PLAYER_SEEK_TO_END_TO_RESYNC: 23, 23: "IOS_PLAYER_SEEK_TO_END_TO_RESYNC",
    IOS_SEEK_ACCESSIBILITY_BUTTON: 24, 24: "IOS_SEEK_ACCESSIBILITY_BUTTON",
    FINE_SCRUBBER_SLIDE_ON_FILMSTRIP: 25, 25: "FINE_SCRUBBER_SLIDE_ON_FILMSTRIP",
    FINE_SCRUBBER_TAP_ON_FILMSTRIP: 26, 26: "FINE_SCRUBBER_TAP_ON_FILMSTRIP",
    FINE_SCRUBBER_SLIDE_ON_SCRUBBER_BAR: 27, 27: "FINE_SCRUBBER_SLIDE_ON_SCRUBBER_BAR",
    SEEK_BUTTON_ON_PLAYER_CONTROL: 28, 28: "SEEK_BUTTON_ON_PLAYER_CONTROL",
    SABR_INGESTION_WALL_TIME_SEEK: 29, 29: "SABR_INGESTION_WALL_TIME_SEEK",
    PLAYER_VIEW_REPARENT_INTERNAL: 30, 30: "PLAYER_VIEW_REPARENT_INTERNAL",
    PRESS_REWIND_PLAY_BACK_CONTROL: 31, 31: "PRESS_REWIND_PLAY_BACK_CONTROL",
    PRESS_FAST_FORWARD_PLAY_BACK_CONTROL: 32, 32: "PRESS_FAST_FORWARD_PLAY_BACK_CONTROL",
    PRESS_LIVE_SYNC_ICON: 33, 33: "PRESS_LIVE_SYNC_ICON",
    PEG_TO_LIVE: 34, 34: "PEG_TO_LIVE",
    ANDROID_MEDIA_SESSION: 35, 35: "ANDROID_MEDIA_SESSION",
    TAP_ON_REPLAY_ACTION: 36, 36: "TAP_ON_REPLAY_ACTION",
    AUTOMATIC_REPLAY_ACTION: 37, 37: "AUTOMATIC_REPLAY_ACTION",
    NON_USER_SEEK_TO_PREVIOUS: 38, 38: "NON_USER_SEEK_TO_PREVIOUS",
    NON_USER_SEEK_TO_NEXT: 39, 39: "NON_USER_SEEK_TO_NEXT",
    HIGHLIGHTS_TAP_PREVIOUS_PLAY: 66, 66: "HIGHLIGHTS_TAP_PREVIOUS_PLAY",
    HIGHLIGHTS_TAP_NEXT_PLAY: 40, 40: "HIGHLIGHTS_TAP_NEXT_PLAY",
    HIGHLIGHTS_TAP_HIDDEN_NEXT_PLAY: 41, 41: "HIGHLIGHTS_TAP_HIDDEN_NEXT_PLAY",
    HIGHLIGHTS_TAP_LIST_ITEM: 42, 42: "HIGHLIGHTS_TAP_LIST_ITEM",
    HIGHLIGHTS_AUTOMATIC_NEXT_PLAY: 43, 43: "HIGHLIGHTS_AUTOMATIC_NEXT_PLAY",
    HIGHLIGHTS_SEEK_TO_FIRST_PLAY: 44, 44: "HIGHLIGHTS_SEEK_TO_FIRST_PLAY",
    HIGHLIGHTS_SEEK_TO_END: 45, 45: "HIGHLIGHTS_SEEK_TO_END",
    SEGMENTS_TAP_LIST_ITEM: 46, 46: "SEGMENTS_TAP_LIST_ITEM",
    PIP_FAST_FORWARD_BUTTON: 47, 47: "PIP_FAST_FORWARD_BUTTON",
    PIP_REWIND_BUTTON: 48, 48: "PIP_REWIND_BUTTON",
    PIP_RESUME_ON_HEAD: 49, 49: "PIP_RESUME_ON_HEAD",
    MOVING_CLIP_FRAME: 50, 50: "MOVING_CLIP_FRAME",
    RESUME_CLIP_PREVIOUS_POSITION: 51, 51: "RESUME_CLIP_PREVIOUS_POSITION",
    SEEK_TO_NEXT_CHAPTER: 52, 52: "SEEK_TO_NEXT_CHAPTER",
    SEEK_TO_PREVIOUS_CHAPTER: 53, 53: "SEEK_TO_PREVIOUS_CHAPTER",
    IOS_SHAREPLAY_PAUSE: 54, 54: "IOS_SHAREPLAY_PAUSE",
    IOS_SHAREPLAY_SEEK: 55, 55: "IOS_SHAREPLAY_SEEK",
    IOS_SHAREPLAY_SYNC_RESPONSE: 56, 56: "IOS_SHAREPLAY_SYNC_RESPONSE",
    SEEK_TO_HEAD_IMMERSIVE_LIVE_VIDEO: 57, 57: "SEEK_TO_HEAD_IMMERSIVE_LIVE_VIDEO",
    SEEK_TO_START_OF_LOOPING_RANGE_OF_SHORTS: 58, 58: "SEEK_TO_START_OF_LOOPING_RANGE_OF_SHORTS",
    SABR_SEEK_TO_CLOSEST_KEYFRAME: 59, 59: "SABR_SEEK_TO_CLOSEST_KEYFRAME",
    SEEK_TO_END_OF_LOOPING_RANGE_OF_SHORTS: 60, 60: "SEEK_TO_END_OF_LOOPING_RANGE_OF_SHORTS",
    CLIP_SLIDE_ON_FLIMSTRIP: 61, 61: "CLIP_SLIDE_ON_FLIMSTRIP",
    PICK_UP_CLIP_SLIDER: 62, 62: "PICK_UP_CLIP_SLIDER",
    FINE_SCRUBBER_CANCELLED: 63, 63: "FINE_SCRUBBER_CANCELLED",
    INLINE_PLAYER_SEEK_CHAPTER: 64, 64: "INLINE_PLAYER_SEEK_CHAPTER",
    INLINE_PLAYER_SEEK_SECONDS: 65, 65: "INLINE_PLAYER_SEEK_SECONDS",
    HIGHLIGHTS_PLAYER_EXIT_FULLSCREEN: 67, 67: "HIGHLIGHTS_PLAYER_EXIT_FULLSCREEN",
    LARGE_CONTROLS_FORWARD_BUTTON: 68, 68: "LARGE_CONTROLS_FORWARD_BUTTON",
    LARGE_CONTROLS_REWIND_BUTTON: 69, 69: "LARGE_CONTROLS_REWIND_BUTTON",
    LARGE_CONTROLS_SCRUBBER_BAR: 70, 70: "LARGE_CONTROLS_SCRUBBER_BAR",
    SEEK_BACKWARD_5S: 71, 71: "SEEK_BACKWARD_5S",
    SEEK_FORWARD_5S: 72, 72: "SEEK_FORWARD_5S",
    SEEK_BACKWARD_10S: 73, 73: "SEEK_BACKWARD_10S",
    SEEK_FORWARD_10S: 74, 74: "SEEK_FORWARD_10S",
    SEEK_FORWARD_60S: 75, 75: "SEEK_FORWARD_60S",
    SEEK_BACKWARD_60S: 76, 76: "SEEK_BACKWARD_60S",
    SEEK_TO_NEXT_FRAME: 77, 77: "SEEK_TO_NEXT_FRAME",
    SEEK_TO_PREV_FRAME: 78, 78: "SEEK_TO_PREV_FRAME",
    KEYBOARD_SEEK_TO_BEGINNING: 79, 79: "KEYBOARD_SEEK_TO_BEGINNING",
    KEYBOARD_SEEK_TO_END: 80, 80: "KEYBOARD_SEEK_TO_END",
    SEEK_PERCENT_OF_VIDEO: 81, 81: "SEEK_PERCENT_OF_VIDEO",
    HIDDEN_FAST_FORWARD_BUTTON: 82, 82: "HIDDEN_FAST_FORWARD_BUTTON",
    HIDDEN_REWIND_BUTTON: 83, 83: "HIDDEN_REWIND_BUTTON",
    TIMESTAMP: 84, 84: "TIMESTAMP",
    LR_MEDIA_SESSION_SEEK: 87, 87: "LR_MEDIA_SESSION_SEEK",
    MIDROLLS_WITH_TIME_RANGE: 88, 88: "MIDROLLS_WITH_TIME_RANGE",
    SKIP_AD: 89, 89: "SKIP_AD",
    SEEK_TO_PREVIOUS: 90, 90: "SEEK_TO_PREVIOUS",
    SEEK_TO_NEXT: 91, 91: "SEEK_TO_NEXT",
    LR_QUICK_SEEK: 92, 92: "LR_QUICK_SEEK",
    ONESIE_LIVE: 93, 93: "ONESIE_LIVE",
    LR_PLAYER_CONTROL_ACTION: 94, 94: "LR_PLAYER_CONTROL_ACTION",
    UNPLUGGED_LENS_START_CLIP: 95, 95: "UNPLUGGED_LENS_START_CLIP",
    LR_KEY_PLAYS: 96, 96: "LR_KEY_PLAYS",
    SSAP_AD_FMT_FATAL: 97, 97: "SSAP_AD_FMT_FATAL",
    TVHTML5_INPUT_SOURCE_KEY_EVENT: 98, 98: "TVHTML5_INPUT_SOURCE_KEY_EVENT",
    TVHTML5_INPUT_SOURCE_CONTROLS: 99, 99: "TVHTML5_INPUT_SOURCE_CONTROLS",
    TVHTML5_INPUT_SOURCE_TOUCH: 100, 100: "TVHTML5_INPUT_SOURCE_TOUCH",
    TVHTML5_INPUT_SOURCE_TOUCHPAD: 101, 101: "TVHTML5_INPUT_SOURCE_TOUCHPAD",
    SEEK_TO_HEAD: 102, 102: "SEEK_TO_HEAD",
    AUTOMATIC_PREVIEW_REPLAY_ACTION: 103, 103: "AUTOMATIC_PREVIEW_REPLAY_ACTION",
    H5_MEDIA_ELEMENT_EVENT: 104, 104: "H5_MEDIA_ELEMENT_EVENT",
    H5_WORKAROUND_SEEK: 105, 105: "H5_WORKAROUND_SEEK",
    MINIPLAYER_REWIND_BUTTON: 106, 106: "MINIPLAYER_REWIND_BUTTON",
    MINIPLAYER_FAST_FORWARD_BUTTON: 107, 107: "MINIPLAYER_FAST_FORWARD_BUTTON",
    SABR_RELOAD_PLAYER_RESPONSE_TOKEN_SEEK: 108, 108: "SABR_RELOAD_PLAYER_RESPONSE_TOKEN_SEEK",
    SLIDE_ON_SCRUBBER_BAR_CHAPTER: 109, 109: "SLIDE_ON_SCRUBBER_BAR_CHAPTER",
    ANDROID_CLEAR_BUFFER: 110, 110: "ANDROID_CLEAR_BUFFER",
    UNRECOGNIZED: -1, "-1": "UNRECOGNIZED"
};
export const OnesieRequestTarget = {
    UNKNOWN: 0, 0: "UNKNOWN",
    ENCRYPTED_PLAYER_SERVICE: 1, 1: "ENCRYPTED_PLAYER_SERVICE",
    ENCRYPTED_WATCH_SERVICE_DEPRECATED: 2, 2: "ENCRYPTED_WATCH_SERVICE_DEPRECATED",
    ENCRYPTED_WATCH_SERVICE: 3, 3: "ENCRYPTED_WATCH_SERVICE",
    INNERTUBE_ENCRYPTED_SERVICE: 4, 4: "INNERTUBE_ENCRYPTED_SERVICE",
    UNRECOGNIZED: -1, "-1": "UNRECOGNIZED"
};
function createBaseHttpHeader() {
    return { name: "", value: "" };
}
export const HttpHeader = {
    encode(message, writer = new BinaryWriter()) {
        if (message.name !== undefined && message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.value !== undefined && message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHttpHeader();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseFormatId() {
    return { itag: 0, lastModified: "0", xtags: "" };
}
export const FormatId = {
    encode(message, writer = new BinaryWriter()) {
        if (message.itag !== undefined && message.itag !== 0) {
            writer.uint32(8).int32(message.itag);
        }
        if (message.lastModified !== undefined && message.lastModified !== "0") {
            writer.uint32(16).uint64(message.lastModified);
        }
        if (message.xtags !== undefined && message.xtags !== "") {
            writer.uint32(26).string(message.xtags);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFormatId();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.itag = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.lastModified = reader.uint64().toString();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.xtags = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseRange() {
    return { legacyStart: 0, legacyEnd: 0, start: 0, end: 0 };
}
export const Range = {
    encode(message, writer = new BinaryWriter()) {
        if (message.legacyStart !== undefined && message.legacyStart !== 0) {
            writer.uint32(8).int32(message.legacyStart);
        }
        if (message.legacyEnd !== undefined && message.legacyEnd !== 0) {
            writer.uint32(16).int32(message.legacyEnd);
        }
        if (message.start !== undefined && message.start !== 0) {
            writer.uint32(24).int32(message.start);
        }
        if (message.end !== undefined && message.end !== 0) {
            writer.uint32(32).int32(message.end);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRange();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.legacyStart = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.legacyEnd = reader.int32();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.start = reader.int32();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.end = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseIdentifierToken() {
    return { requestNumber: 0, field5: 0 };
}
export const IdentifierToken = {
    encode(message, writer = new BinaryWriter()) {
        if (message.requestNumber !== undefined && message.requestNumber !== 0) {
            writer.uint32(8).int32(message.requestNumber);
        }
        if (message.field5 !== undefined && message.field5 !== 0) {
            writer.uint32(40).int32(message.field5);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIdentifierToken();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.requestNumber = reader.int32();
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.field5 = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseKeyValuePair() {
    return { key: "", value: "" };
}
export const KeyValuePair = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== undefined && message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined && message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseKeyValuePair();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBaseAuthorizedFormat() {
    return { trackType: 0, isHdr: false };
}
export const AuthorizedFormat = {
    encode(message, writer = new BinaryWriter()) {
        if (message.trackType !== undefined && message.trackType !== 0) {
            writer.uint32(8).int32(message.trackType);
        }
        if (message.isHdr !== undefined && message.isHdr !== false) {
            writer.uint32(16).bool(message.isHdr);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuthorizedFormat();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.trackType = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.isHdr = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
function createBasePlaybackAuthorization() {
    return { authorizedFormats: [], sabrLicenseConstraint: new Uint8Array(0) };
}
export const PlaybackAuthorization = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.authorizedFormats) {
            AuthorizedFormat.encode(v, writer.uint32(10).fork()).join();
        }
        if (message.sabrLicenseConstraint !== undefined && message.sabrLicenseConstraint.length !== 0) {
            writer.uint32(18).bytes(message.sabrLicenseConstraint);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlaybackAuthorization();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.authorizedFormats.push(AuthorizedFormat.decode(reader, reader.uint32()));
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.sabrLicenseConstraint = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
};
//# sourceMappingURL=common.js.map